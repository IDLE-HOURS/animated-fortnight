{"version":3,"sources":["webpack:///./node_modules/react-loads/es/index.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperty","key","value","Object","defineProperty","enumerable","configurable","writable","_objectSpread","target","i","arguments","length","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","forEach","_slicedToArray","arr","Array","isArray","_arrayWithHoles","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","err","_iterableToArrayLimit","TypeError","_nonIterableRest","_toConsumableArray","arr2","_arrayWithoutHoles","iter","from","_iterableToArray","_nonIterableSpread","invocationTimestamps","Map","recordsCache","records","clear","opts","cacheProvider","delete","set","valOrFn","record","get","cacheTimeout","clearTimeout","val","cacheTime","setTimeout","updated","Date","promises","revalidators","suspenders","updaters","CACHE_STRATEGIES","LOAD_POLICIES","STATES","defaultConfig","cacheStrategy","debounce","debounceCache","dedupingInterval","delay","defer","loadPolicy","revalidateOnWindowFocus","revalidateTime","suspense","throwError","timeout","Context","noop","usePrevious","ref","current","useTimeout","_setTimeout","fn","ms","_clearTimeout","isDocumentVisible","document","visibilityState","getCacheKey","_ref","context","variablesHash","cacheKey","join","IDLE_RECORD","error","response","state","useLoads","localConfig","config","dedupeManualLoad","_initialResponse","initialResponse","onReject","onResolve","pollingInterval","pollWhile","pollWhenHidden","rejectRetryInterval","updateFn","update","variables","JSON","stringify","loadCount","debounceCount","prevCacheKey","isSameContext","isSameVariables","_useDetectMounted2","hasMounted","hasRendered","useDetectMounted","_useTimeout2","setDelayTimeout","clearDelayTimeout","setErrorRetryTimeout","_useTimeout6","setTimeoutTimeout","clearTimeoutTimeout","cachedRecord","initialRecord","reducer","action","type","isCached","_React$useReducer2","dispatch","handleLoading","isReloading","isSlow","promise","handleData","_ref2","count","shouldBroadcast","Boolean","isSuspended","updaters$$1","updater","broadcastChanges","handleOptimisticData","_ref3","data","contextOrCallback","callback","newData","optimisticCacheKey","_variablesHash","cachedValue","newRecord","newCallback","load","_len","_args","_key","_opts$setInvocationTi","setInvocationTimestamp","isManualInvoke","args","arg","name","now","getTime","latestInvocationTimestamp","Math","abs","apply","isDuplicate","isStale","isCachedWithCacheFirst","loadFn","promiseOrFn","setResponse","setError","then","catch","_count","min","_timeout","random","map","reset","prevContext","newUpdaters","revalidate","shouldPoll","savedCallback","id","setInterval","clearInterval","useInterval","states","isIdle","isPending","isPendingSlow","isResolved","isRejected","isReloadingSlow","_record","eventsBinded","window","addEventListener","navigator","onLine","revalidator","useDeferredLoads","contextOrFn","fnOrConfig","maybeConfig"],"mappings":"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","file":"1324fedac16f742ca7c4aee2ffc2723090c845e5-72039a91fc730f0f5520.js","sourcesContent":["import \"core-js/modules/es.array.reduce\";\nimport \"core-js/modules/es.promise.finally\";\nimport { createContext, useMemo, createElement, useRef, useEffect, useCallback, useContext, useReducer, useState } from 'react';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n} ////////////////////////////////////////////////////////\n\n\nvar invocationTimestamps = new Map(); ////////////////////////////////////////////////////////\n\nvar recordsCache = new Map();\nvar records = {\n  clear: function clear(opts) {\n    recordsCache.clear();\n\n    if (opts && opts.cacheProvider) {\n      opts.cacheProvider.clear();\n    }\n\n    return;\n  },\n  delete: function _delete(key, opts) {\n    recordsCache.delete(key);\n\n    if (opts && opts.cacheProvider) {\n      opts.cacheProvider.delete(key);\n    }\n\n    return;\n  },\n  set: function set(key, valOrFn, opts) {\n    var record = recordsCache.get(key);\n\n    if (record && record.cacheTimeout) {\n      clearTimeout(record.cacheTimeout);\n    }\n\n    var val = valOrFn;\n\n    if (typeof val === 'function') {\n      val = val(record || {});\n    }\n\n    var cacheTimeout;\n\n    if (opts && opts.cacheTime) {\n      cacheTimeout = setTimeout(function () {\n        records.delete(key);\n      }, opts.cacheTime);\n    } // Set an updated timestamp on the cached record\n\n\n    val = _objectSpread({}, val, {\n      cacheTimeout: cacheTimeout,\n      updated: new Date()\n    });\n    recordsCache.set(key, val);\n\n    if (opts && opts.cacheProvider) {\n      opts.cacheProvider.set(key, val);\n    }\n\n    return;\n  },\n  get: function get(key, opts) {\n    // First, check to see if the record exists in the cache.\n    var record = recordsCache.get(key);\n\n    if (record) {\n      return record;\n    } // Otherwise, fallback to the cache provider.\n\n\n    if (opts && opts.cacheProvider) {\n      var value = opts.cacheProvider.get(key);\n\n      if (value) {\n        return value;\n      }\n    }\n\n    return undefined;\n  }\n}; ////////////////////////////////////////////////////////\n\nvar promises = new Map();\nvar revalidators = new Map();\nvar suspenders = new Map();\nvar updaters = new Map();\nvar cache = /*#__PURE__*/Object.freeze({\n  invocationTimestamps: invocationTimestamps,\n  records: records,\n  promises: promises,\n  revalidators: revalidators,\n  suspenders: suspenders,\n  updaters: updaters\n});\nvar CACHE_STRATEGIES = {\n  CONTEXT_ONLY: 'context-only',\n  CONTEXT_AND_VARIABLES: 'context-and-variables'\n};\nvar LOAD_POLICIES = {\n  CACHE_FIRST: 'cache-first',\n  CACHE_AND_LOAD: 'cache-and-load',\n  LOAD_ONLY: 'load-only',\n  CACHE_ONLY: 'cache-only'\n};\nvar STATES = {\n  IDLE: 'idle',\n  PENDING: 'pending',\n  PENDING_SLOW: 'pending-slow',\n  RESOLVED: 'resolved',\n  REJECTED: 'rejected',\n  RELOADING: 'reloading',\n  RELOADING_SLOW: 'reloading-slow'\n};\nvar defaultConfig = {\n  cacheTime: 0,\n  cacheStrategy: CACHE_STRATEGIES.CONTEXT_AND_VARIABLES,\n  debounce: 0,\n  debounceCache: true,\n  dedupingInterval: 500,\n  delay: 0,\n  defer: false,\n  loadPolicy: LOAD_POLICIES.CACHE_AND_LOAD,\n  revalidateOnWindowFocus: false,\n  revalidateTime: 300000,\n  suspense: false,\n  throwError: false,\n  timeout: 5000\n};\nvar Context = createContext(defaultConfig);\n\nfunction Provider(_ref) {\n  var children = _ref.children,\n      config = _ref.config;\n  var newConfig = useMemo(function () {\n    return Object.assign(defaultConfig, config);\n  }, [config]);\n  return createElement(Context.Provider, {\n    value: newConfig\n  }, children);\n}\n\nfunction useDetectMounted() {\n  var hasMounted = useRef(true);\n  var hasRendered = useRef(false);\n  useEffect(function () {\n    hasRendered.current = true;\n    return function cleanup() {\n      hasMounted.current = false;\n    };\n  }, []);\n  return [hasMounted, hasRendered];\n}\n\nvar noop = function noop() {};\n\nfunction useInterval(callback, delay) {\n  var savedCallback = useRef(noop);\n  useEffect(function () {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(function () {\n    var handler = function handler() {\n      return savedCallback.current.apply(savedCallback, arguments);\n    };\n\n    if (typeof delay === 'number') {\n      var id = setInterval(handler, delay);\n      return function () {\n        return clearInterval(id);\n      };\n    }\n\n    return;\n  }, [delay]);\n}\n\nfunction usePrevious(value) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nfunction useTimeout() {\n  var timeout = useRef(undefined);\n\n  var _setTimeout = useCallback(function (fn, ms) {\n    // @ts-ignore\n    timeout.current = setTimeout(fn, ms);\n  }, []);\n\n  var _clearTimeout = useCallback(function () {\n    return clearTimeout(timeout.current);\n  }, []);\n\n  useEffect(function () {\n    return function cleanup() {\n      if (timeout) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, []);\n  return [_setTimeout, _clearTimeout];\n}\n\nfunction isDocumentVisible() {\n  if (typeof document !== 'undefined' && typeof document.visibilityState !== 'undefined') {\n    return document.visibilityState !== 'hidden';\n  }\n\n  return true;\n}\n\nfunction isOnline() {\n  if (typeof navigator.onLine !== 'undefined') {\n    return navigator.onLine;\n  }\n\n  return true;\n}\n\nfunction getCacheKey(_ref) {\n  var context = _ref.context,\n      variablesHash = _ref.variablesHash,\n      cacheStrategy = _ref.cacheStrategy;\n  var cacheKey = Array.isArray(context) ? context.join('.') : context;\n\n  if (variablesHash && cacheStrategy === CACHE_STRATEGIES.CONTEXT_AND_VARIABLES) {\n    cacheKey = \"\".concat(cacheKey, \".\").concat(variablesHash);\n  }\n\n  return cacheKey;\n}\n\nfunction broadcastChanges(cacheKey, record) {\n  var updaters$$1 = updaters.get(cacheKey);\n\n  if (updaters$$1) {\n    updaters$$1.forEach(function (updater) {\n      return updater({\n        record: record,\n        shouldBroadcast: false\n      });\n    });\n  }\n}\n\nvar IDLE_RECORD = {\n  error: undefined,\n  response: undefined,\n  state: STATES.IDLE\n};\n\nfunction useLoads(context, fn, localConfig) {\n  var globalConfig = useContext(Context);\n\n  var config = _objectSpread({}, globalConfig, localConfig || {});\n\n  var cacheProvider = config.cacheProvider,\n      cacheStrategy = config.cacheStrategy,\n      cacheTime = config.cacheTime,\n      debounce = config.debounce,\n      debounceCache = config.debounceCache,\n      dedupingInterval = config.dedupingInterval,\n      dedupeManualLoad = config.dedupeManualLoad,\n      delay = config.delay,\n      _initialResponse = config.initialResponse,\n      loadPolicy = config.loadPolicy,\n      onReject = config.onReject,\n      onResolve = config.onResolve,\n      pollingInterval = config.pollingInterval,\n      pollWhile = config.pollWhile,\n      pollWhenHidden = config.pollWhenHidden,\n      rejectRetryInterval = config.rejectRetryInterval,\n      revalidateOnWindowFocus = config.revalidateOnWindowFocus,\n      revalidateTime = config.revalidateTime,\n      suspense = config.suspense,\n      throwError = config.throwError,\n      timeout = config.timeout,\n      updateFn = config.update;\n  var defer = config.defer;\n  var variables = config.variables;\n\n  if (typeof variables === 'function') {\n    try {\n      variables = variables();\n      defer = config.defer;\n    } catch (err) {\n      defer = true;\n    }\n  }\n\n  var variablesHash = useMemo(function () {\n    return JSON.stringify(variables);\n  }, [variables]);\n  var cacheKey = getCacheKey({\n    context: context,\n    variablesHash: variablesHash,\n    cacheStrategy: cacheStrategy\n  });\n  var loadCount = useRef(0);\n  var debounceCount = useRef(0);\n  var prevCacheKey = usePrevious(cacheKey);\n  var isSameContext = !prevCacheKey || prevCacheKey === cacheKey;\n  var prevVariablesHash = usePrevious(JSON.stringify(variables));\n  var isSameVariables = variablesHash === prevVariablesHash;\n\n  var _useDetectMounted = useDetectMounted(),\n      _useDetectMounted2 = _slicedToArray(_useDetectMounted, 2),\n      hasMounted = _useDetectMounted2[0],\n      hasRendered = _useDetectMounted2[1];\n\n  var _useTimeout = useTimeout(),\n      _useTimeout2 = _slicedToArray(_useTimeout, 2),\n      setDelayTimeout = _useTimeout2[0],\n      clearDelayTimeout = _useTimeout2[1];\n\n  var _useTimeout3 = useTimeout(),\n      _useTimeout4 = _slicedToArray(_useTimeout3, 1),\n      setErrorRetryTimeout = _useTimeout4[0];\n\n  var _useTimeout5 = useTimeout(),\n      _useTimeout6 = _slicedToArray(_useTimeout5, 2),\n      setTimeoutTimeout = _useTimeout6[0],\n      clearTimeoutTimeout = _useTimeout6[1];\n\n  var cachedRecord = useMemo(function () {\n    if (cacheKey && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {\n      return records.get(cacheKey, {\n        cacheProvider: cacheProvider\n      });\n    }\n\n    return;\n  }, [cacheProvider, cacheKey, loadPolicy]);\n  var initialResponse = useMemo(function () {\n    return _initialResponse;\n  }, []); // eslint-disable-line\n\n  var initialRecord = initialResponse ? {\n    response: initialResponse,\n    error: undefined,\n    state: STATES.RESOLVED\n  } : _objectSpread({}, IDLE_RECORD, {\n    state: defer ? STATES.IDLE : STATES.PENDING\n  });\n\n  if (cachedRecord && !defer) {\n    initialRecord = cachedRecord;\n  }\n\n  var reducer = useCallback(function (state, action) {\n    switch (action.type) {\n      case STATES.IDLE:\n        return IDLE_RECORD;\n\n      case STATES.PENDING:\n        return _objectSpread({}, state, {\n          state: STATES.PENDING\n        });\n\n      case STATES.PENDING_SLOW:\n        return _objectSpread({}, state, {\n          state: STATES.PENDING_SLOW\n        });\n\n      case STATES.RESOLVED:\n        return {\n          isCached: action.isCached,\n          error: undefined,\n          response: action.response,\n          state: STATES.RESOLVED\n        };\n\n      case STATES.REJECTED:\n        return {\n          isCached: action.isCached,\n          error: action.error,\n          response: undefined,\n          state: STATES.REJECTED\n        };\n\n      case STATES.RELOADING:\n        return _objectSpread({}, state, {\n          state: STATES.RELOADING\n        });\n\n      case STATES.RELOADING_SLOW:\n        return _objectSpread({}, state, {\n          state: STATES.RELOADING_SLOW\n        });\n\n      default:\n        return state;\n    }\n  }, []);\n\n  var _React$useReducer = useReducer(reducer, initialRecord),\n      _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n      record = _React$useReducer2[0],\n      dispatch = _React$useReducer2[1];\n\n  var handleLoading = useCallback(function (_ref) {\n    var isReloading = _ref.isReloading,\n        isSlow = _ref.isSlow,\n        promise = _ref.promise;\n    var reloadingState = isSlow ? STATES.RELOADING_SLOW : STATES.RELOADING;\n    var pendingState = isSlow ? STATES.PENDING_SLOW : STATES.PENDING;\n    dispatch({\n      type: isReloading ? reloadingState : pendingState\n    });\n\n    if (cacheKey) {\n      records.set(cacheKey, function (record) {\n        return _objectSpread({}, record, {\n          state: isReloading ? STATES.RELOADING : STATES.PENDING\n        });\n      }, {\n        cacheTime: cacheTime,\n        cacheProvider: cacheProvider\n      });\n\n      if (!isReloading) {\n        promises.set(cacheKey, promise);\n      }\n    }\n  }, [cacheProvider, cacheTime, cacheKey]);\n  var handleData = useCallback(function (_ref2) {\n    var count = _ref2.count,\n        record = _ref2.record,\n        shouldBroadcast = _ref2.shouldBroadcast;\n\n    if (hasMounted.current && (!count || count === loadCount.current)) {\n      // @ts-ignore\n      clearDelayTimeout(); // @ts-ignore\n\n      clearTimeoutTimeout();\n      dispatch(_objectSpread({\n        type: record.state,\n        isCached: Boolean(cacheKey)\n      }, record));\n\n      if (cacheKey) {\n        records.set(cacheKey, record, {\n          cacheProvider: cacheProvider,\n          cacheTime: cacheTime\n        });\n        var isSuspended = suspenders.get(cacheKey);\n        suspenders.set(cacheKey, typeof isSuspended === 'undefined');\n        promises.delete(cacheKey);\n\n        if (shouldBroadcast) {\n          broadcastChanges(cacheKey, record);\n        }\n      }\n    }\n  }, [cacheProvider, cacheTime, clearDelayTimeout, clearTimeoutTimeout, cacheKey, hasMounted]);\n  var handleOptimisticData = useCallback(function (_ref3, state, count) {\n    var data = _ref3.data,\n        contextOrCallback = _ref3.contextOrCallback,\n        callback = _ref3.callback;\n    var newData = data;\n    var optimisticCacheKey = cacheKey;\n\n    if (_typeof(contextOrCallback) === 'object') {\n      var _variablesHash = JSON.stringify(contextOrCallback.variables);\n\n      optimisticCacheKey = getCacheKey({\n        context: contextOrCallback.context,\n        variablesHash: _variablesHash,\n        cacheStrategy: cacheStrategy\n      });\n    }\n\n    if (typeof data === 'function') {\n      var cachedValue = IDLE_RECORD;\n\n      if (optimisticCacheKey) {\n        cachedValue = records.get(optimisticCacheKey, {\n          cacheProvider: cacheProvider\n        }) || IDLE_RECORD;\n      }\n\n      newData = data(state === STATES.RESOLVED ? cachedValue.response : cachedValue.error);\n    }\n\n    var newRecord = {\n      error: state === STATES.REJECTED ? newData : undefined,\n      response: state === STATES.RESOLVED ? newData : undefined,\n      state: state\n    };\n\n    if (!optimisticCacheKey || cacheKey === optimisticCacheKey) {\n      handleData({\n        count: count,\n        record: newRecord,\n        shouldBroadcast: true\n      });\n    } else {\n      records.set(optimisticCacheKey, newRecord, {\n        cacheProvider: cacheProvider,\n        cacheTime: cacheTime\n      });\n    }\n\n    var newCallback = typeof contextOrCallback === 'function' ? contextOrCallback : callback;\n    newCallback && newCallback(newData);\n  }, [cacheStrategy, cacheKey, cacheProvider, handleData, cacheTime]);\n  var load = useCallback(function () {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function () {\n      for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n        _args[_key] = arguments[_key];\n      }\n\n      var _opts$setInvocationTi = opts.setInvocationTimestamp,\n          setInvocationTimestamp = _opts$setInvocationTi === void 0 ? true : _opts$setInvocationTi;\n\n      if (!opts.isManualInvoke && variables && isSameVariables) {\n        return;\n      } // Build cacheKey based of these args?\n\n\n      var args = _args.filter(function (arg) {\n        return arg.constructor.name !== 'Class';\n      });\n\n      if (variables && (!args || args.length === 0)) {\n        args = variables;\n      }\n\n      if (context && debounce > 0) {\n        var now = new Date().getTime();\n\n        if (setInvocationTimestamp) {\n          invocationTimestamps.set(context, now);\n          invocationTimestamps.set('latest', now);\n        }\n\n        var latestInvocationTimestamp = invocationTimestamps.get(context || 'latest');\n\n        if (latestInvocationTimestamp) {\n          if (Math.abs(now - latestInvocationTimestamp) < debounce) {\n            debounceCount.current = debounceCount.current + 1;\n            setTimeout(function () {\n              return load(_objectSpread({\n                count: debounceCount.current,\n                setInvocationTimestamp: false\n              }, opts)).apply(void 0, _args);\n            }, debounce);\n            return;\n          }\n\n          if (debounceCount.current !== (opts.count || 0)) {\n            return;\n          }\n        }\n\n        debounceCount.current = 0;\n      }\n\n      var cachedRecord;\n\n      if (cacheKey) {\n        cachedRecord = records.get(cacheKey, {\n          cacheProvider: cacheProvider\n        });\n      }\n\n      if (cachedRecord) {\n        var isDuplicate = // @ts-ignore\n        Math.abs(new Date() - cachedRecord.updated) < dedupingInterval && (!opts.isManualInvoke || dedupeManualLoad);\n        if (isDuplicate) return;\n      }\n\n      loadCount.current = loadCount.current + 1;\n      var count = loadCount.current;\n\n      if (cacheKey) {\n        var isSuspended = suspenders.get(cacheKey);\n\n        if (suspense && isSuspended) {\n          suspenders.set(cacheKey, false);\n          return;\n        }\n      }\n\n      if (cacheKey && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {\n        if (!defer && cachedRecord) {\n          dispatch(_objectSpread({\n            type: cachedRecord.state,\n            isCached: true\n          }, cachedRecord));\n\n          if (cachedRecord.state === STATES.RESOLVED || cachedRecord.state === STATES.REJECTED) {\n            // @ts-ignore\n            var isStale = Math.abs(new Date() - cachedRecord.updated) >= revalidateTime;\n            var isCachedWithCacheFirst = !isStale && !opts.isManualInvoke && loadPolicy === LOAD_POLICIES.CACHE_FIRST;\n            if (isCachedWithCacheFirst) return;\n          }\n        }\n      }\n\n      var loadFn = opts.fn ? opts.fn : fn;\n      var promiseOrFn = loadFn.apply(void 0, _toConsumableArray(args));\n      var promise = promiseOrFn;\n\n      if (typeof promiseOrFn === 'function') {\n        promise = promiseOrFn({\n          cachedRecord: cachedRecord,\n          setResponse: function setResponse(data, contextOrCallback, callback) {\n            return handleOptimisticData({\n              data: data,\n              contextOrCallback: contextOrCallback,\n              callback: callback\n            }, STATES.RESOLVED, count);\n          },\n          setError: function setError(data, contextOrCallback, callback) {\n            return handleOptimisticData({\n              data: data,\n              contextOrCallback: contextOrCallback,\n              callback: callback\n            }, STATES.REJECTED, count);\n          }\n        });\n      }\n\n      var isReloading = context && isSameContext && (count > 1 || cachedRecord && !defer || initialResponse) || debounce > 0 && debounceCache;\n\n      if (delay > 0) {\n        setDelayTimeout(function () {\n          return handleLoading({\n            isReloading: isReloading,\n            promise: promise\n          });\n        }, delay);\n      } else {\n        handleLoading({\n          isReloading: isReloading,\n          promise: promise\n        });\n      }\n\n      if (timeout > 0) {\n        setTimeoutTimeout(function () {\n          return handleLoading({\n            isReloading: isReloading,\n            isSlow: true,\n            promise: promise\n          });\n        }, timeout);\n      }\n\n      if (typeof promise === 'function') return;\n      return promise.then(function (response) {\n        handleData({\n          count: count,\n          record: {\n            error: undefined,\n            response: response,\n            state: STATES.RESOLVED\n          },\n          shouldBroadcast: true\n        });\n        onResolve && onResolve(response);\n        return response;\n      }).catch(function (error) {\n        handleData({\n          count: count,\n          record: {\n            response: undefined,\n            error: error,\n            state: STATES.REJECTED\n          },\n          shouldBroadcast: false\n        });\n        onReject && onReject(error);\n\n        if (rejectRetryInterval) {\n          var _count = Math.min(loadCount.current || 0, 8);\n\n          var _timeout = typeof rejectRetryInterval === 'function' ? rejectRetryInterval(_count) : ~~((Math.random() + 0.5) * (1 << _count)) * rejectRetryInterval;\n\n          setErrorRetryTimeout(function () {\n            return load()(args);\n          }, _timeout);\n        }\n\n        if (throwError && !suspense) {\n          throw error;\n        }\n      });\n    };\n  }, [variablesHash, isSameVariables, context, debounce, cacheKey, loadPolicy, fn, isSameContext, defer, initialResponse, debounceCache, delay, timeout, cacheProvider, dedupingInterval, dedupeManualLoad, suspense, revalidateTime, handleOptimisticData, setDelayTimeout, handleLoading, setTimeoutTimeout, handleData, onResolve, onReject, rejectRetryInterval, throwError, setErrorRetryTimeout]);\n  var update = useMemo(function () {\n    if (!updateFn) return;\n\n    if (Array.isArray(updateFn)) {\n      return updateFn.map(function (fn) {\n        return load({\n          fn: fn,\n          isManualInvoke: true\n        });\n      });\n    }\n\n    return load({\n      fn: updateFn,\n      isManualInvoke: true\n    });\n  }, [load, updateFn]);\n  var reset = useCallback(function () {\n    dispatch({\n      type: STATES.IDLE\n    });\n  }, []);\n  var prevContext = usePrevious(context);\n  useEffect(function () {\n    if (context !== prevContext) {\n      reset();\n    }\n  }, [context, prevContext, reset]);\n  useEffect(function () {\n    if (!cachedRecord && cacheKey && !initialResponse && !debounceCache) {\n      reset();\n    }\n  }, [cachedRecord, cacheKey, initialResponse, reset, debounceCache]);\n  useEffect(function () {\n    if (cachedRecord && !defer && loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {\n      dispatch(_objectSpread({\n        type: cachedRecord.state,\n        isCached: true\n      }, cachedRecord));\n    }\n  }, [cachedRecord, loadPolicy, dispatch, defer]);\n  useEffect(function () {\n    if (defer || suspense && !hasRendered.current && !cachedRecord || loadPolicy === LOAD_POLICIES.CACHE_ONLY) return;\n    load()();\n  }, [defer, cacheKey, suspense, hasRendered, cachedRecord, load, loadPolicy]);\n  useEffect(function () {\n    if (defer) return;\n    var updaters$$1 = updaters.get(cacheKey);\n\n    if (updaters$$1) {\n      var newUpdaters = [].concat(_toConsumableArray(updaters$$1), [handleData]);\n      updaters.set(cacheKey, newUpdaters);\n    } else {\n      updaters.set(cacheKey, [handleData]);\n    }\n\n    return function cleanup() {\n      var updaters$$1 = updaters.get(cacheKey);\n      var newUpdaters = updaters$$1.filter(function (updater) {\n        return updater !== handleData;\n      });\n      updaters.set(cacheKey, newUpdaters);\n    };\n  }, [cacheKey, defer, handleData]);\n  useEffect(function () {\n    if (!revalidateOnWindowFocus || defer) return;\n    var revalidate = load();\n    revalidators.set(cacheKey, revalidate);\n    return function cleanup() {\n      revalidators.delete(cacheKey);\n    };\n  }, [cacheKey, defer, handleData, load, revalidateOnWindowFocus]);\n  var shouldPoll = !defer;\n\n  if (shouldPoll && pollWhile) {\n    if (typeof pollWhile === 'function') {\n      shouldPoll = pollWhile(record);\n    } else {\n      shouldPoll = pollWhile;\n    }\n  }\n\n  useInterval(function () {\n    if (!isDocumentVisible() && !pollWhenHidden) return;\n    load({\n      isManualInvoke: true\n    })();\n  }, shouldPoll ? pollingInterval : undefined);\n  var states = useMemo(function () {\n    return {\n      isIdle: record.state === STATES.IDLE && Boolean(!record.response),\n      isPending: record.state === STATES.PENDING || record.state === STATES.PENDING_SLOW,\n      isPendingSlow: record.state === STATES.PENDING_SLOW,\n      isResolved: record.state === STATES.RESOLVED || Boolean(record.response),\n      isRejected: record.state === STATES.REJECTED,\n      isReloading: record.state === STATES.RELOADING || record.state === STATES.RELOADING_SLOW,\n      isReloadingSlow: record.state === STATES.RELOADING_SLOW\n    };\n  }, [record.response, record.state]);\n\n  if (suspense && !defer) {\n    if (cacheKey) {\n      var _record = records.get(cacheKey);\n\n      var promise = promises.get(cacheKey);\n\n      if (_record && promise) {\n        throw promise;\n      }\n\n      if (!_record) {\n        load()();\n      }\n    }\n\n    if (states.isRejected) {\n      throw record.error;\n    }\n  }\n\n  return useMemo(function () {\n    return _objectSpread({\n      load: load({\n        isManualInvoke: true\n      }),\n      update: update,\n      reset: reset,\n      response: record.response,\n      error: record.error,\n      state: record.state\n    }, states, {\n      isCached: Boolean(record.isCached)\n    });\n  }, [load, update, reset, record.response, record.error, record.state, record.isCached, states]);\n}\n\nvar eventsBinded = false;\n\nif (typeof window !== 'undefined' && window.addEventListener && !eventsBinded) {\n  var revalidate = function revalidate() {\n    if (!isDocumentVisible() || !isOnline()) return;\n    revalidators.forEach(function (revalidator) {\n      return revalidator && revalidator();\n    });\n  };\n\n  window.addEventListener('visibilitychange', revalidate, false);\n  window.addEventListener('focus', revalidate, false);\n  eventsBinded = true;\n}\n\nfunction preload(context, promiseOrFn, localConfig) {\n  var config = _objectSpread({}, defaultConfig, localConfig || {});\n\n  var cacheTime = config.cacheTime,\n      cacheProvider = config.cacheProvider,\n      cacheStrategy = config.cacheStrategy,\n      dedupingInterval = config.dedupingInterval,\n      loadPolicy = config.loadPolicy,\n      onResolve = config.onResolve,\n      onReject = config.onReject,\n      rejectRetryInterval = config.rejectRetryInterval,\n      revalidateTime = config.revalidateTime,\n      suspense = config.suspense,\n      throwError = config.throwError,\n      variables = config.variables;\n\n  function setData(_ref) {\n    var cacheKey = _ref.cacheKey,\n        record = _ref.record;\n    var config = {\n      cacheProvider: cacheProvider,\n      cacheTime: cacheTime\n    };\n    records.set(cacheKey, record, config);\n  }\n\n  var count = 0;\n\n  function load() {\n    count = count + 1;\n    var args = variables || [];\n\n    if (typeof args === 'function') {\n      try {\n        args = args() || [];\n      } catch (err) {\n        throw new Error('TODO');\n      }\n    }\n\n    var variablesHash = JSON.stringify(args);\n    var cacheKey = getCacheKey({\n      context: context,\n      variablesHash: variablesHash,\n      cacheStrategy: cacheStrategy\n    });\n    if (!cacheKey) throw new Error('preload() must have a context');\n    var cachedRecord;\n\n    if (loadPolicy !== LOAD_POLICIES.LOAD_ONLY) {\n      cachedRecord = records.get(cacheKey);\n    }\n\n    if (cachedRecord) {\n      // @ts-ignore\n      var isStale = Math.abs(new Date() - cachedRecord.updated) >= revalidateTime;\n      var isDuplicate = // @ts-ignore\n      Math.abs(new Date() - cachedRecord.updated) < dedupingInterval;\n      var isCachedWithCacheFirst = !isStale && loadPolicy === LOAD_POLICIES.CACHE_FIRST;\n      if (isDuplicate || isCachedWithCacheFirst) return;\n    }\n\n    var promise = promiseOrFn.apply(void 0, _toConsumableArray(args));\n\n    if (typeof promise === 'function') {\n      promise = promise({\n        cachedRecord: cachedRecord\n      });\n    }\n\n    var isReloading = Boolean(cachedRecord);\n    records.set(cacheKey, function (record) {\n      return _objectSpread({}, record, {\n        state: cachedRecord ? STATES.RELOADING : STATES.PENDING\n      });\n    }, {\n      cacheTime: cacheTime,\n      cacheProvider: cacheProvider\n    });\n\n    if (!isReloading) {\n      promises.set(cacheKey, promise);\n    }\n\n    if (typeof promise === 'function') return;\n    promise.then(function (response) {\n      var record = {\n        error: undefined,\n        response: response,\n        state: STATES.RESOLVED\n      };\n      setData({\n        cacheKey: cacheKey,\n        record: record\n      });\n      onResolve && onResolve(response);\n    }).catch(function (error) {\n      var record = {\n        response: undefined,\n        error: error,\n        state: STATES.REJECTED\n      };\n      setData({\n        cacheKey: cacheKey,\n        record: record\n      });\n      onReject && onReject(error);\n\n      if (rejectRetryInterval) {\n        var attemptCount = Math.min(count || 0, 8);\n        var timeout = typeof rejectRetryInterval === 'function' ? rejectRetryInterval(attemptCount) : ~~((Math.random() + 0.5) * (1 << attemptCount)) * rejectRetryInterval;\n        setTimeout(function () {\n          return load();\n        }, timeout);\n      }\n\n      if (throwError && !suspense) {\n        throw error;\n      }\n    }).finally(function () {\n      promises.delete(cacheKey);\n    });\n  }\n\n  load();\n  return {\n    useLoads: function useLoads$$1() {\n      var loadsConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return useLoads(context, promiseOrFn, _objectSpread({}, config, loadsConfig, {\n        loadPolicy: LOAD_POLICIES.CACHE_ONLY\n      }));\n    }\n  };\n}\n\nfunction useDeferredLoads(contextOrFn, fnOrConfig, maybeConfig) {\n  var context = contextOrFn;\n  var config = maybeConfig;\n  var fn = fnOrConfig;\n\n  if (typeof contextOrFn === 'function') {\n    context = null;\n    fn = contextOrFn;\n  }\n\n  if (_typeof(fnOrConfig) === 'object') {\n    config = fnOrConfig;\n  }\n\n  return useLoads(context, fn, _objectSpread({}, config, {\n    defer: true\n  }));\n}\n\nfunction createLoadsHooks(opts) {\n  return Object.entries(opts).reduce(function (currentLoaders, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        loadKey = _ref2[0],\n        val = _ref2[1];\n\n    if (loadKey[0] === '_' || typeof val === 'string') return currentLoaders;\n    var loader = val;\n    var config = {};\n\n    if (Array.isArray(val)) {\n      loader = val[0];\n      config = val[1] || {};\n    }\n\n    if (loadKey === 'fn') {\n      return _objectSpread({}, currentLoaders, {\n        preload: function preload$$1(loadsConfig) {\n          return preload(opts.context, loader, _objectSpread({}, config, loadsConfig));\n        },\n        useLoads: function useLoads$$1(loadsConfig) {\n          return useLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));\n        },\n        useDeferredLoads: function useDeferredLoads$$1(loadsConfig) {\n          return useDeferredLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));\n        }\n      });\n    }\n\n    return _objectSpread({}, currentLoaders, _defineProperty({}, loadKey, {\n      preload: function preload$$1(loadsConfig) {\n        return preload(opts.context, loader, _objectSpread({}, config, loadsConfig));\n      },\n      useLoads: function useLoads$$1(loadsConfig) {\n        return useLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));\n      },\n      useDeferredLoads: function useDeferredLoads$$1(loadsConfig) {\n        return useDeferredLoads(opts.context, loader, _objectSpread({}, config, loadsConfig));\n      }\n    }));\n  }, {});\n}\n\nfunction createResource(opts) {\n  return _objectSpread({}, createLoadsHooks(opts));\n}\n\nvar Loads = function Loads(_ref) {\n  var children = _ref.children,\n      context = _ref.context,\n      fn = _ref.fn,\n      inputs = _ref.inputs,\n      config = _objectWithoutProperties(_ref, [\"children\", \"context\", \"fn\", \"inputs\"]);\n\n  var record = useLoads(context, fn, config);\n  return children(record);\n};\n\nLoads.defaultProps = {\n  inputs: []\n};\n\nfunction useCache(context) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      variables = _ref.variables;\n\n  var cacheKey = Array.isArray(context) ? context.join('.') : context;\n  var variablesHash = useMemo(function () {\n    return JSON.stringify(variables);\n  }, [variables]);\n\n  if (variablesHash) {\n    cacheKey = \"\".concat(cacheKey, \".\").concat(variablesHash);\n  }\n\n  var _React$useState = useState(function () {\n    return records.get(cacheKey);\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      record = _React$useState2[0],\n      setRecord = _React$useState2[1];\n\n  var handleData = useCallback(function (_ref2) {\n    var record = _ref2.record;\n    setRecord(record);\n  }, []);\n  useEffect(function () {\n    var updaters$$1 = updaters.get(cacheKey);\n\n    if (updaters$$1) {\n      var newUpdaters = [].concat(_toConsumableArray(updaters$$1), [handleData]);\n      updaters.set(cacheKey, newUpdaters);\n    } else {\n      updaters.set(cacheKey, [handleData]);\n    }\n  });\n  return record;\n}\n\nfunction useGetStates() {\n  for (var _len = arguments.length, records = new Array(_len), _key = 0; _key < _len; _key++) {\n    records[_key] = arguments[_key];\n  }\n\n  var isIdle = useMemo(function () {\n    return !records.some(function (record) {\n      return !record.isIdle;\n    });\n  }, [records]);\n  var isPending = useMemo(function () {\n    return records.some(function (record) {\n      return record.isPending;\n    });\n  }, [records]);\n  var isPendingSlow = useMemo(function () {\n    return records.some(function (record) {\n      return record.isPendingSlow;\n    });\n  }, [records]);\n  var isResolved = useMemo(function () {\n    return !records.some(function (record) {\n      return !record.isResolved && !record.isIdle;\n    });\n  }, [records]);\n  var isRejected = useMemo(function () {\n    return records.some(function (record) {\n      return record.isRejected;\n    });\n  }, [records]);\n  var isReloading = useMemo(function () {\n    return records.some(function (record) {\n      return record.isReloading;\n    });\n  }, [records]);\n  var isReloadingSlow = useMemo(function () {\n    return records.some(function (record) {\n      return record.isReloadingSlow;\n    });\n  }, [records]);\n  return useMemo(function () {\n    return {\n      isIdle: isIdle,\n      isPending: isPending,\n      isPendingSlow: isPendingSlow,\n      isResolved: isResolved,\n      isRejected: isRejected,\n      isReloading: isReloading,\n      isReloadingSlow: isReloadingSlow\n    };\n  }, [isIdle, isPending, isPendingSlow, isRejected, isReloading, isReloadingSlow, isResolved]);\n}\n\nexport { cache, invocationTimestamps, records, promises, revalidators, suspenders, updaters, createResource, Loads, defaultConfig, Context, Provider, preload, useCache, useLoads, useDeferredLoads, useGetStates };"],"sourceRoot":""}